#!/usr/bin/env bash
set -euo pipefail

# parse parameters
declare BUILD_TAG=test
declare CONTAINER_NAME
BASE_NAME=$(basename "$(pwd)")
CONTAINER_NAME=${BASE_NAME}--test
while getopts b:c: opt
do
   case "${opt}" in
   b) BUILD_TAG="${OPTARG}";;
   c) CONTAINER_NAME="${OPTARG}";;
   ?) printf "Usage: %s [-b [BUILD_TAG]] [-c CONTAINER_NAME]\n" "$0"
      exit 2;;
   esac
done
shift $((OPTIND - 1))

# build image
echo "$(tput setaf 7)ℹ$(tput sgr0) Building ${BUILD_TAG}"
DEFAULT_TAG="${BUILD_TAG}" docker buildx bake image-local --progress=plain # --no-cache

# clean up on exit
#trap clean_up EXIT

function clean_up() {
  echo "$(tput setaf 7)ℹ$(tput sgr0) Cleaning up"
  docker rm -f "${CONTAINER_NAME}" >/dev/null 2>&1 || true
  if [ -e data ] && ! rm -rf data; then
    echo "Failed to delete data. Try the following command to resolve this issue:"
    echo "docker run --rm -v '$(pwd):/work' ubuntu bash -c 'chmod -R +w /work/data; rm -rf /work/data'"
    exit 1
  fi
  if [ -e disk.img ] && ! rm -f disk.img; then
    echo "Failed to delete data. Try the following command to resolve this issue:"
    echo "docker run --rm -v '$(pwd):/work' ubuntu bash -c 'chmod -R +w /work/disk.img; rm -rf /work/disk.img'"
    exit 1
  fi
}

function should() {
  echo ""
  echo " $(tput setaf 1)◀$(tput sgr0)$(tput setaf 2)▶$(tput sgr0) $(tput bold)should" "$@" "$(tput sgr0)"
  clean_up
}

# test if container logs contain EXPECTED_OUT within TIMEOUT_S seconds
function docker_test_output() {
  local -r -i TIMEOUT_S="$1"; shift
  local -r EXPECTED_OUT="$1"; shift

  local -r -i TIMEOUT=$((SECONDS + TIMEOUT_S))
  while read -r LOGLINE; do
    echo "${LOGLINE}"
    if [[ "${LOGLINE}" == *"${EXPECTED_OUT}"* ]]; then
      echo "$(tput setaf 2)✔$(tput sgr0) printed '${EXPECTED_OUT}'"
      return 0
    fi
    if [[ "${SECONDS}" -gt "${TIMEOUT}" ]]; then
      >&2 echo "$(tput setaf 1)✘$(tput sgr0) did not print '${EXPECTED_OUT}' within ${TIMEOUT_S}s"
      exit 1
    fi
  done < <(docker logs -f "${CONTAINER_NAME}" 2>&1)
  >&2 echo "$(tput setaf 1)✘$(tput sgr0) did not print '${EXPECTED_OUT}'"
  exit 1
}

# test if container has EXPECTED_STATUS
function docker_test_status() {
  local -r -i TIMEOUT_S="$1"; shift
  local -r EXPECTED_STATUS="$1"; shift

  local -r -i TIMEOUT=$((SECONDS + TIMEOUT_S))
  local ACTUAL_STATUS
  while true; do
    ACTUAL_STATUS=$(docker container inspect --format "{{.State.Status}}" "${CONTAINER_NAME}")
    if [[ "${ACTUAL_STATUS}" == "${EXPECTED_STATUS}" ]]; then
      echo "$(tput setaf 2)✔$(tput sgr0) status '${EXPECTED_STATUS}'"
      return 0
    fi
    if [[ "${SECONDS}" -gt "${TIMEOUT}" ]]; then
      >&2 echo "$(tput setaf 1)✘$(tput sgr0) status '${ACTUAL_STATUS}' != '${EXPECTED_STATUS}'"
      exit 1
    fi
    sleep 1
  done
}

should print usage
docker run -d --name "${CONTAINER_NAME}" "${BUILD_TAG}"
docker_test_output 10 "Usage: COMMAND [ARG...]"
docker_test_status 10 "exited"

should print tool help
docker run -d --name "${CONTAINER_NAME}" "${BUILD_TAG}" guestfish --help
docker_test_output 10 "guestfish: guest filesystem shell"
docker_test_status 10 "exited"

should execute guestfish script
cp test/tinycore.iso disk.img
docker run -i --name "${CONTAINER_NAME}" \
  -e "PUID=$(id -u)" \
  -e "PGID=$(id -g)" \
  -e "LIBGUESTFS_DEBUG=0" \
  -e "LIBGUESTFS_TRACE=0" \
  -v "$(pwd)/data:/data" \
  -v "$(pwd)/disk.img:/disk.img" \
  "${BUILD_TAG}" \
  guestfish \
  --ro \
  --add /disk.img \
  --mount /dev/sda:/ \
<<COMMANDS
copy-out "/boot/core.gz" "data"
umount-all
exit
COMMANDS
docker_test_status 10 "exited"
if [[ -f data/core.gz ]]; then
  echo "$(tput setaf 2)✔$(tput sgr0) did copy-out 'data/core.gz'"
else
  >&2 echo "$(tput setaf 1)✘$(tput sgr0) did not copy-out 'data/core.gz'"
  exit 1
fi
if [[ -r data/core.gz ]]; then
  echo "$(tput setaf 2)✔$(tput sgr0) 'data/core.gz' is readible"
else
  >&2 echo "$(tput setaf 1)✘$(tput sgr0) 'data/core.gz' is not readible"
  exit 1
fi
if [[ "$(ls -ld data/core.gz | awk '{print $3}')" == "$(whoami)" ]]; then
  echo "$(tput setaf 2)✔$(tput sgr0) is owner of 'data/core.gz'"
else
  >&2 echo "$(tput setaf 1)✘$(tput sgr0) is not owner of 'data/core.gz'"
  exit 1
fi
if [[ "$(wc -c data/core.gz | awk '{ print $1 }')" -gt 1000000 ]]; then
  echo "$(tput setaf 2)✔$(tput sgr0) 'data/core.gz' is reasonibly large"
else
  >&2 echo "$(tput setaf 1)✘$(tput sgr0) 'data/core.gz' is too small"
  exit 1
fi
